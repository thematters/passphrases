import { Dict, IndexDict } from './definitions'
import {
  DictError,
  PassphrasesExpiredError,
  PassphrasesMismatchError,
} from './errors'
import { generate } from './generate'
import { fromTimeDiff } from './utils'

/**
 * Verify passphrases
 */
type Verify = {
  // passphrases generated by generate()
  passphrases: string[]

  // signing
  // payload data without `exp`
  sigPayload: {
    [key: string]: number | string
  }
  sigAlgorithm?: 'sha256' | 'sha512'
  sigSecret: string

  // dictionaries to map signature and expiration date to words
  sigDict: Dict
  expDict: Dict
  expDictDiffSince?: number

  // dictionary to map `exp` word to timestamp
  expIndexDict: IndexDict

  // take first n passphrases
  take?: number
}

export const verify = async ({
  passphrases,
  expIndexDict,
  expDictDiffSince,
  ...props
}: Verify) => {
  // check expiration date
  const [expWord] = passphrases
  const exp = await expIndexDict.get(expWord)

  if (!exp || exp < 0) throw new DictError('Unable to convert expWord to exp.')

  const expirationDate = fromTimeDiff(exp, expDictDiffSince)
  if (expirationDate < Date.now()) {
    throw new PassphrasesExpiredError('Passphrases expired.')
  }

  // compare passphrases
  const newPassphrases = await generate({
    ...props,
    expDictDiffSince,
    sigPayload: { ...props.sigPayload, exp: expirationDate },
  })
  const isSame = passphrases.join('') === newPassphrases.join('')
  if (!isSame) {
    throw new PassphrasesMismatchError('Passphrases mismatch.')
  }

  return true
}
